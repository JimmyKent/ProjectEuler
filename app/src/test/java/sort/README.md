基于比较的排序:
下界是O(n log n)
证明:《算法导论》第三版 第八章107页  
bubbleSort      起泡排序  
mergeSort       归并  
selectionSort   选择排序(如果是基于列表的,可以进行改进为堆排序)  
insertSort      插入排序(基于列表)  
heapSort        堆排序(改进的选择排序,在选最大(最小)值时,可以从O(n)的时间降低为O(log n))  
quickSort       快速排序  
shellSort       希尔排序  

```
/**
 * 基于二分查找的排序: 从头开始取每个数,然后根据二分查找返回的是不大于当前元素e的最后一个元素
 * 二分查找是O(log n), 那么基于这个思路的排序就是O(n log n)
 * 这个方案就是SelectionSort, SelectionSort是基于列表的,
 * 如果是基于向量(数组)是没办法做的,因为会存在后缀整体后移的问题
 * 这个错误在插入排序表现出来.
 */
```

归并排序 vs 快速排序  

归并排序: 重点在归并  
快速排序: 重点在分, 合并的时候只是简单的合并  


//TODO 要有流程图就很清晰了  

不是基于比较的排序:  
下界是O(n)  

当被排序的数有一些性质的时候（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于的。  
比如  
计数排序 复杂度 要求：被排序的数是0~k范围内的整数  
基数排序 复杂度 要求：d位数，每个数位有k个取值  
桶排序 复杂度 （平均） 要求：被排序数在某个范围内，并且服从均匀分布  