基于比较的排序:
下界是O(n log n)
证明:《算法导论》第三版 第八章107页
bubbleSort      起泡排序
mergeSort       归并
selectionSort   选择
insertSort      插入排序
heapSort        堆排序
quickSort       快速排序
shellSort       希尔排序
```
/**
 * 基于二分查找的排序: 从头开始取每个数,然后根据二分查找返回的是不大于当前元素e的最后一个元素
 * 二分查找是O(log n), 那么基于这个思路的排序就是O(n log n)
 * 这个方案就是SelectionSort, SelectionSort是基于列表的,
 * 如果是基于向量(数组)是没办法做的,因为会存在后缀整体后移的问题
 * 这个错误在插入排序表现出来.
 */
```

//TODO 要有流程图就很清晰了

不是基于比较的排序:
桶排序 O(n)

当被排序的数有一些性质的时候（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于的。
比如
计数排序 复杂度 要求：被排序的数是0~k范围内的整数
基数排序 复杂度 要求：d位数，每个数位有k个取值
桶排序 复杂度 （平均） 要求：被排序数在某个范围内，并且服从均匀分布